"""
Multi-Agent Fantasy Football Server with advanced analytics and real-time data integration.
"""

import asyncio
import logging
from typing import Dict, Any, List, Optional
from datetime import datetime, timedelta
from fastapi import FastAPI, HTTPException, BackgroundTasks, Depends
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, Field
import uvicorn
import os

from ..agents.coordinator import AgentCoordinator, AgentContext
from ..agents.llm_integration import LLMManager
from ..scrapers.sleeper_api import SleeperAPI
from ..database.vector_store import VectorManager, PatternStore

logger = logging.getLogger(__name__)

# Pydantic Models
class AdvancedAnalysisRequest(BaseModel):
    league_id: str
    username: str
    query: str
    analysis_type: str = Field(default="comprehensive", description="Type of analysis: comprehensive, matchup, waiver, trade")
    include_weather: bool = True
    include_sentiment: bool = True
    brutality_mode: bool = True
    use_vector_context: bool = True

class ChatRequest(BaseModel):
    league_id: str
    username: str
    message: str
    context_type: str = Field(default="all", description="Context to include: all, recent, patterns")
    use_react_prompting: bool = True

class WaiverAnalysisRequest(BaseModel):
    league_id: str
    username: str
    faab_budget_remaining: float
    weeks_remaining: int
    target_positions: List[str] = []
    risk_tolerance: str = Field(default="medium", description="Risk tolerance: low, medium, high")

class TradeAnalysisRequest(BaseModel):
    league_id: str
    username: str
    giving_players: List[str]
    receiving_players: List[str]
    trade_context: str = Field(default="", description="Additional context about the trade")
    playoff_focus: bool = True

class AdvancedAnalysisResult(BaseModel):
    success: bool = True
    analysis: str
    structured_analysis: Dict[str, Any]
    agent_results: Dict[str, Any]
    llm_reasoning: Dict[str, Any]
    confidence_score: float
    recommendations: List[str]
    data_sources: Dict[str, bool]
    execution_summary: Dict[str, Any]
    vector_context: Optional[Dict[str, Any]] = None
    timestamp: str

class MultiAgentFantasyServer:
    """
    Advanced multi-agent fantasy football server with real-time data integration.
    """
    
    def __init__(self, enable_vector_db: bool = True, enable_background_tasks: bool = True):
        self.app = FastAPI(
            title="Fantasy Football AI Multi-Agent System",
            description="Advanced analytics using multiple AI agents with real-time data",
            version="2.0.0"
        )
        
        # Initialize components
        self.agent_coordinator = AgentCoordinator()
        self.llm_manager = LLMManager()
        self.vector_manager = VectorManager() if enable_vector_db else None
        self.pattern_store = PatternStore(self.vector_manager) if enable_vector_db else None
        
        # Performance tracking
        self.request_count = 0
        self.performance_metrics = {
            "avg_response_time": 0.0,
            "total_requests": 0,
            "error_rate": 0.0,
            "agent_performance": {}
        }
        
        # Setup middleware and routes
        self._setup_middleware()
        self._setup_routes()
        
        # Background tasks
        if enable_background_tasks:
            self._setup_background_tasks()\n    \n    def _setup_middleware(self):\n        \"\"\"Setup CORS and other middleware.\"\"\"\n        self.app.add_middleware(\n            CORSMiddleware,\n            allow_origins=[\"http://localhost:5173\", \"http://localhost:5174\", \"http://localhost:3000\"],\n            allow_credentials=True,\n            allow_methods=[\"*\"],\n            allow_headers=[\"*\"],\n        )\n    \n    def _setup_routes(self):\n        \"\"\"Setup API routes.\"\"\"\n        \n        @self.app.get(\"/\")\n        async def root():\n            return {\n                \"message\": \"Fantasy Football AI Multi-Agent System\",\n                \"version\": \"2.0.0\",\n                \"status\": \"running\",\n                \"agents_available\": len(self.agent_coordinator.agents),\n                \"vector_db_enabled\": self.vector_manager is not None\n            }\n        \n        @self.app.get(\"/api/v2/health\")\n        async def health_check():\n            \"\"\"Advanced health check with agent status.\"\"\"\n            agent_health = {}\n            for agent_name, agent in self.agent_coordinator.agents.items():\n                agent_health[agent_name] = {\n                    \"healthy\": agent.is_healthy,\n                    \"metrics\": agent.get_performance_metrics()\n                }\n            \n            return {\n                \"status\": \"healthy\",\n                \"timestamp\": datetime.now().isoformat(),\n                \"performance_metrics\": self.performance_metrics,\n                \"agent_health\": agent_health,\n                \"vector_db_status\": self.vector_manager.get_stats() if self.vector_manager else \"disabled\"\n            }\n        \n        @self.app.post(\"/api/v2/analyze-comprehensive\")\n        async def analyze_comprehensive(request: AdvancedAnalysisRequest, background_tasks: BackgroundTasks) -> AdvancedAnalysisResult:\n            \"\"\"Comprehensive analysis using all available agents and data sources.\"\"\"\n            start_time = datetime.now()\n            \n            try:\n                # Get comprehensive Sleeper data\n                async with SleeperAPI() as sleeper:\n                    analysis_data = await sleeper.get_user_analysis_data(request.league_id, request.username)\n                \n                if \"error\" in analysis_data:\n                    raise HTTPException(status_code=404, detail=analysis_data[\"error\"])\n                \n                # Create agent context\n                context = AgentContext(\n                    league_id=request.league_id,\n                    username=request.username,\n                    user_id=analysis_data[\"user_data\"][\"user_id\"],\n                    query=request.query,\n                    query_type=request.analysis_type,\n                    league_settings=analysis_data[\"league_data\"][\"league_info\"] or {},\n                    roster_data=analysis_data[\"user_roster\"] or {},\n                    historical_data=analysis_data.get(\"current_stats\"),\n                    real_time_data=analysis_data.get(\"projections\")\n                )\n                \n                # Get vector context if enabled\n                vector_context = None\n                if request.use_vector_context and self.pattern_store:\n                    vector_context = await self.pattern_store.get_player_context(\n                        request.username, \"all\"\n                    )\n                \n                # Execute multi-agent workflow\n                agent_results = await self.agent_coordinator.process_query(context)\n                \n                # Perform LLM analysis with ReAct prompting\n                llm_analysis = None\n                if request.analysis_type == \"comprehensive\":\n                    llm_analysis = await self.llm_manager.team_analysis({\n                        **analysis_data,\n                        \"agent_results\": agent_results\n                    })\n                \n                # Calculate execution time\n                execution_time = (datetime.now() - start_time).total_seconds()\n                \n                # Update performance metrics\n                self._update_performance_metrics(execution_time, True)\n                \n                # Store patterns in background\n                if self.pattern_store:\n                    background_tasks.add_task(\n                        self._store_analysis_patterns,\n                        analysis_data, agent_results, llm_analysis\n                    )\n                \n                # Extract recommendations\n                recommendations = self._extract_recommendations(agent_results, llm_analysis)\n                \n                return AdvancedAnalysisResult(\n                    analysis=llm_analysis.get(\"analysis\", agent_results.get(\"analysis\", \"Analysis completed\")) if llm_analysis else agent_results.get(\"analysis\", \"Analysis completed\"),\n                    structured_analysis=agent_results,\n                    agent_results=agent_results.get(\"agent_results\", {}),\n                    llm_reasoning=llm_analysis or {},\n                    confidence_score=agent_results.get(\"confidence\", 0.8),\n                    recommendations=recommendations,\n                    data_sources={\n                        \"sleeper_api\": True,\n                        \"multi_agent_system\": True,\n                        \"llm_analysis\": llm_analysis is not None,\n                        \"vector_database\": vector_context is not None,\n                        \"real_time_data\": True\n                    },\n                    execution_summary={\n                        \"execution_time_seconds\": execution_time,\n                        \"agents_executed\": len(agent_results.get(\"agent_results\", {})),\n                        \"data_sources_used\": analysis_data.keys(),\n                        \"llm_model_used\": llm_analysis.get(\"model_used\") if llm_analysis else None\n                    },\n                    vector_context=vector_context,\n                    timestamp=datetime.now().isoformat()\n                )\n                \n            except HTTPException:\n                raise\n            except Exception as e:\n                self._update_performance_metrics(0, False)\n                logger.error(f\"Comprehensive analysis failed: {str(e)}\")\n                raise HTTPException(status_code=500, detail=f\"Analysis failed: {str(e)}\")\n        \n        @self.app.post(\"/api/v2/chat-advanced\")\n        async def chat_advanced(request: ChatRequest) -> Dict[str, Any]:\n            \"\"\"Advanced chat with ReAct prompting and context awareness.\"\"\"\n            try:\n                # Get user context\n                async with SleeperAPI() as sleeper:\n                    analysis_data = await sleeper.get_user_analysis_data(request.league_id, request.username)\n                \n                # Get vector context if available\n                context_data = {}\n                if self.pattern_store:\n                    context_data = await self.pattern_store.get_player_context(\n                        request.username, request.context_type\n                    )\n                \n                # Determine analysis type from message\n                analysis_type = self._classify_message(request.message)\n                \n                # Use appropriate LLM analysis\n                if analysis_type == \"matchup\" and \"player\" in request.message.lower():\n                    # Extract player names from message for matchup analysis\n                    players = self._extract_player_names(request.message)\n                    llm_response = await self.llm_manager.matchup_analysis(\n                        {**analysis_data, **context_data}, players\n                    )\n                elif analysis_type == \"waiver\":\n                    # Get trending players for waiver analysis\n                    async with SleeperAPI() as sleeper:\n                        trending = await sleeper.get_trending_players(\"add\")\n                    llm_response = await self.llm_manager.waiver_wire_analysis(\n                        {**analysis_data, **context_data}, trending\n                    )\n                else:\n                    # General team analysis\n                    llm_response = await self.llm_manager.team_analysis(\n                        {**analysis_data, **context_data}\n                    )\n                \n                return {\n                    \"success\": True,\n                    \"response\": llm_response.get(\"analysis\", \"I need more information to provide a detailed analysis.\"),\n                    \"structured_output\": llm_response.get(\"structured_output\", {}),\n                    \"analysis_type\": analysis_type,\n                    \"confidence\": llm_response.get(\"structured_output\", {}).get(\"confidence\", 0.7),\n                    \"model_used\": llm_response.get(\"model_used\", \"fallback\"),\n                    \"context_used\": bool(context_data),\n                    \"timestamp\": datetime.now().isoformat()\n                }\n                \n            except Exception as e:\n                logger.error(f\"Advanced chat failed: {str(e)}\")\n                return {\n                    \"success\": False,\n                    \"response\": f\"I encountered an error processing your request: {str(e)}\",\n                    \"analysis_type\": \"error\",\n                    \"confidence\": 0.1,\n                    \"timestamp\": datetime.now().isoformat()\n                }\n        \n        @self.app.post(\"/api/v2/waiver-analysis\")\n        async def waiver_analysis(request: WaiverAnalysisRequest) -> Dict[str, Any]:\n            \"\"\"Advanced waiver wire analysis with FAAB optimization.\"\"\"\n            try:\n                # Get comprehensive league data\n                async with SleeperAPI() as sleeper:\n                    analysis_data = await sleeper.get_user_analysis_data(request.league_id, request.username)\n                    trending_adds = await sleeper.get_trending_players(\"add\")\n                \n                # Prepare waiver context\n                waiver_context = {\n                    **analysis_data,\n                    \"faab_remaining\": request.faab_budget_remaining,\n                    \"weeks_remaining\": request.weeks_remaining,\n                    \"target_positions\": request.target_positions,\n                    \"risk_tolerance\": request.risk_tolerance\n                }\n                \n                # Get LLM waiver analysis\n                llm_analysis = await self.llm_manager.waiver_wire_analysis(\n                    waiver_context, trending_adds\n                )\n                \n                return {\n                    \"success\": True,\n                    \"analysis\": llm_analysis.get(\"analysis\", \"Waiver analysis completed\"),\n                    \"structured_recommendations\": llm_analysis.get(\"structured_output\", {}),\n                    \"trending_players\": trending_adds,\n                    \"faab_strategy\": self._generate_faab_strategy(request, trending_adds),\n                    \"confidence\": llm_analysis.get(\"structured_output\", {}).get(\"confidence\", 0.8),\n                    \"timestamp\": datetime.now().isoformat()\n                }\n                \n            except Exception as e:\n                logger.error(f\"Waiver analysis failed: {str(e)}\")\n                raise HTTPException(status_code=500, detail=f\"Waiver analysis failed: {str(e)}\")\n        \n        @self.app.get(\"/api/v2/performance-metrics\")\n        async def get_performance_metrics():\n            \"\"\"Get detailed performance metrics for the system.\"\"\"\n            return {\n                \"system_metrics\": self.performance_metrics,\n                \"agent_metrics\": {\n                    name: agent.get_performance_metrics() \n                    for name, agent in self.agent_coordinator.agents.items()\n                },\n                \"vector_db_stats\": self.vector_manager.get_stats() if self.vector_manager else None,\n                \"timestamp\": datetime.now().isoformat()\n            }\n    \n    def _setup_background_tasks(self):\n        \"\"\"Setup background tasks for data updates and maintenance.\"\"\"\n        \n        @self.app.on_event(\"startup\")\n        async def startup_tasks():\n            \"\"\"Initialize background tasks on startup.\"\"\"\n            # Schedule periodic vector database cleanup\n            if self.vector_manager:\n                asyncio.create_task(self._periodic_vector_cleanup())\n            \n            # Schedule performance metrics reset\n            asyncio.create_task(self._periodic_metrics_reset())\n            \n            logger.info(\"Background tasks initialized\")\n        \n        @self.app.on_event(\"shutdown\")\n        async def shutdown_tasks():\n            \"\"\"Cleanup on shutdown.\"\"\"\n            if self.vector_manager:\n                await self.vector_manager.close()\n            logger.info(\"Shutdown tasks completed\")\n    \n    async def _periodic_vector_cleanup(self):\n        \"\"\"Periodic cleanup of old vector data.\"\"\"\n        while True:\n            try:\n                await asyncio.sleep(86400)  # Run daily\n                if self.pattern_store:\n                    deleted_count = await self.pattern_store.cleanup_old_patterns(30)\n                    logger.info(f\"Cleaned up {deleted_count} old patterns\")\n            except Exception as e:\n                logger.error(f\"Vector cleanup failed: {str(e)}\")\n    \n    async def _periodic_metrics_reset(self):\n        \"\"\"Periodic reset of performance metrics.\"\"\"\n        while True:\n            try:\n                await asyncio.sleep(3600)  # Reset hourly\n                for agent in self.agent_coordinator.agents.values():\n                    agent.reset_metrics()\n                logger.info(\"Agent metrics reset\")\n            except Exception as e:\n                logger.error(f\"Metrics reset failed: {str(e)}\")\n    \n    async def _store_analysis_patterns(self, analysis_data: Dict[str, Any], \n                                     agent_results: Dict[str, Any], \n                                     llm_analysis: Optional[Dict[str, Any]]):\n        \"\"\"Store analysis patterns in vector database.\"\"\"\n        try:\n            if not self.pattern_store:\n                return\n            \n            # Store player patterns from analysis\n            user_roster = analysis_data.get(\"user_roster\", {})\n            if user_roster and \"players\" in user_roster:\n                for player_id in user_roster[\"players\"][:5]:  # Limit storage\n                    pattern_data = {\n                        \"type\": \"analysis_result\",\n                        \"agent_results\": agent_results,\n                        \"llm_analysis\": llm_analysis,\n                        \"context\": analysis_data.get(\"league_data\", {})\n                    }\n                    \n                    await self.pattern_store.store_player_pattern(\n                        player_id, pattern_data\n                    )\n            \n        except Exception as e:\n            logger.error(f\"Pattern storage failed: {str(e)}\")\n    \n    def _update_performance_metrics(self, execution_time: float, success: bool):\n        \"\"\"Update system performance metrics.\"\"\"\n        self.performance_metrics[\"total_requests\"] += 1\n        \n        if success:\n            # Update average response time\n            prev_avg = self.performance_metrics[\"avg_response_time\"]\n            total = self.performance_metrics[\"total_requests\"]\n            self.performance_metrics[\"avg_response_time\"] = (\n                (prev_avg * (total - 1) + execution_time) / total\n            )\n        \n        # Update error rate\n        error_count = self.performance_metrics.get(\"error_count\", 0)\n        if not success:\n            error_count += 1\n        \n        self.performance_metrics[\"error_rate\"] = error_count / self.performance_metrics[\"total_requests\"]\n        self.performance_metrics[\"error_count\"] = error_count\n    \n    def _extract_recommendations(self, agent_results: Dict[str, Any], \n                               llm_analysis: Optional[Dict[str, Any]]) -> List[str]:\n        \"\"\"Extract actionable recommendations from analysis results.\"\"\"\n        recommendations = []\n        \n        # Extract from agent results\n        if \"key_insights\" in agent_results:\n            recommendations.extend(agent_results[\"key_insights\"])\n        \n        # Extract from LLM analysis\n        if llm_analysis and \"structured_output\" in llm_analysis:\n            structured = llm_analysis[\"structured_output\"]\n            if \"recommendations\" in structured:\n                recommendations.extend(structured[\"recommendations\"])\n        \n        return recommendations[:10]  # Limit to top 10\n    \n    def _classify_message(self, message: str) -> str:\n        \"\"\"Classify user message to determine analysis type.\"\"\"\n        message_lower = message.lower()\n        \n        if any(word in message_lower for word in [\"start\", \"sit\", \"lineup\", \"matchup\"]):\n            return \"matchup\"\n        elif any(word in message_lower for word in [\"waiver\", \"pickup\", \"drop\", \"claim\"]):\n            return \"waiver\"\n        elif any(word in message_lower for word in [\"trade\", \"deal\", \"swap\"]):\n            return \"trade\"\n        else:\n            return \"general\"\n    \n    def _extract_player_names(self, message: str) -> List[str]:\n        \"\"\"Extract player names from message text.\"\"\"\n        # Simple player name extraction - could be enhanced with NLP\n        import re\n        \n        # Look for capitalized names (First Last pattern)\n        names = re.findall(r'\\b[A-Z][a-z]+\\s+[A-Z][a-z]+\\b', message)\n        return names[:5]  # Limit to 5 players\n    \n    def _generate_faab_strategy(self, request: WaiverAnalysisRequest, \n                              trending_players: List[Dict[str, Any]]) -> Dict[str, Any]:\n        \"\"\"Generate FAAB bidding strategy.\"\"\"\n        return {\n            \"budget_remaining\": request.faab_budget_remaining,\n            \"weeks_remaining\": request.weeks_remaining,\n            \"recommended_weekly_allocation\": request.faab_budget_remaining / max(request.weeks_remaining, 1),\n            \"high_priority_targets\": trending_players[:3],\n            \"emergency_reserve\": min(request.faab_budget_remaining * 0.2, 20)\n        }\n    \n    def run(self, host: str = \"0.0.0.0\", port: int = 8001, **kwargs):\n        \"\"\"Run the multi-agent server.\"\"\"\n        uvicorn.run(self.app, host=host, port=port, **kwargs)\n\nif __name__ == \"__main__\":\n    server = MultiAgentFantasyServer()\n    server.run()